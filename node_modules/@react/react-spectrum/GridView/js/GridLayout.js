"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _BaseLayout2 = _interopRequireDefault(require("./BaseLayout"));

var _collectionView = require("@react/collection-view");

/*************************************************************************
* ADOBE CONFIDENTIAL
* ___________________
*
* Copyright 2019 Adobe
* All Rights Reserved.
*
* NOTICE: All information contained herein is, and remains
* the property of Adobe and its suppliers, if any. The intellectual
* and technical concepts contained herein are proprietary to Adobe
* and its suppliers and are protected by all applicable intellectual
* property laws, including trade secret and copyright laws.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe.
**************************************************************************/
var DEFAULT_OPTIONS = {
  S: {
    itemPadding: 20,
    minItemSize: new _collectionView.Size(96, 96),
    maxItemSize: new _collectionView.Size(Infinity, Infinity),
    margin: 8,
    minSpace: new _collectionView.Size(8, 16),
    maxColumns: Infinity,
    dropSpacing: 50
  },
  L: {
    itemPadding: 52,
    minItemSize: new _collectionView.Size(208, 208),
    maxItemSize: new _collectionView.Size(Infinity, Infinity),
    margin: 24,
    minSpace: new _collectionView.Size(24, 48),
    maxColumns: Infinity,
    dropSpacing: 100
  }
};
/**
 * A GridLayout displays equal-sized items in a grid.
 * It works with data in a single section.
 */

var GridLayout =
/*#__PURE__*/
function (_BaseLayout) {
  (0, _inherits2["default"])(GridLayout, _BaseLayout);

  function GridLayout() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck2["default"])(this, GridLayout);
    _this = (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(GridLayout).call(this));
    var cardSize = options.cardSize || 'L';
    /**
     * The minimum item size
     * @type {Size}
     * @default 208 x 208
     */

    _this.minItemSize = options.minItemSize || DEFAULT_OPTIONS[cardSize].minItemSize;
    /**
     * The maximum item size.
     * @type {Size}
     * @default Infinity
     */

    _this.maxItemSize = options.maxItemSize || DEFAULT_OPTIONS[cardSize].maxItemSize;
    /**
     * The margin around the grid view between the edges and the items
     * @type {Size}
     * @default 24
     */

    _this.margin = options.margin != null ? options.margin : DEFAULT_OPTIONS[cardSize].margin;
    /**
     * The minimum space required between items
     * @type {Size}
     * @default 24 x 48
     */

    _this.minSpace = options.minSpace || DEFAULT_OPTIONS[cardSize].minSpace;
    /**
     * The maximum number of columns. Default is infinity.
     * @type {number}
     * @default Infinity
     */

    _this.maxColumns = options.maxColumns || DEFAULT_OPTIONS[cardSize].maxColumns;
    /**
     * The vertical padding for an item
     * @type {number}
     * @default 52
     */

    _this.itemPadding = options.itemPadding != null ? options.itemPadding : DEFAULT_OPTIONS[cardSize].itemPadding;
    /**
     * The space between items created when dragging between them
     * @type {number}
     * @default 100
     */

    _this.dropSpacing = options.dropSpacing != null ? options.dropSpacing : DEFAULT_OPTIONS[cardSize].dropSpacing;
    _this.itemSize = null;
    _this.numColumns = 0;
    _this.numRows = 0;
    _this.horizontalSpacing = 0;
    _this.cardType = 'quiet'; // Better name?

    return _this;
  }

  (0, _createClass2["default"])(GridLayout, [{
    key: "getLayoutInfo",
    value: function getLayoutInfo(type, section, index) {
      var row = Math.floor(index / this.numColumns);
      var column = index % this.numColumns;
      var x = this.margin + column * (this.itemSize.width + this.horizontalSpacing);
      var y = this.margin + row * (this.itemSize.height + this.minSpace.height);

      if (this.shouldShowDropSpacing()) {
        var dropTarget = this.collectionView._dropTarget;
        var dropRow = Math.floor(dropTarget.indexPath.index / this.numColumns);

        if (dropRow === row) {
          x -= this.dropSpacing / 2;

          if (index >= dropTarget.indexPath.index) {
            x += this.dropSpacing;
          }
        }
      }

      var layoutInfo = new _collectionView.LayoutInfo(type, section, index);
      layoutInfo.rect = new _collectionView.Rect(x, y, this.itemSize.width, this.itemSize.height);
      layoutInfo.estimatedSize = false;
      return layoutInfo;
    }
  }, {
    key: "getIndexAtPoint",
    value: function getIndexAtPoint(x, y) {
      var allowInsertingAtEnd = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var itemHeight = this.itemSize.height + this.minSpace.height;
      var itemWidth = this.itemSize.width + this.horizontalSpacing;
      return Math.max(0, Math.min(this.collectionView.getSectionLength(0) - (allowInsertingAtEnd ? 0 : 1), Math.floor(y / itemHeight) * this.numColumns + Math.floor((x - this.horizontalSpacing) / itemWidth)));
    }
  }, {
    key: "getVisibleLayoutInfos",
    value: function getVisibleLayoutInfos(rect) {
      var res = [];
      var numItems = this.collectionView.getSectionLength(0) - 1;

      if (numItems < 0 || !this.itemSize) {
        return res;
      }

      var firstVisibleItem = this.getIndexAtPoint(rect.x, rect.y);
      var lastVisibleItem = this.getIndexAtPoint(rect.maxX, rect.maxY);

      for (var index = firstVisibleItem; index <= lastVisibleItem; index++) {
        var layoutInfo = this.getLayoutInfo('item', 0, index);

        if (rect.intersects(layoutInfo.rect)) {
          res.push(layoutInfo);
        }
      }

      return res;
    }
  }, {
    key: "validate",
    value: function validate() {
      // Compute the number of rows and columns needed to display the content
      var availableWidth = this.collectionView.size.width - this.margin * 2;
      var columns = Math.floor(availableWidth / (this.minItemSize.width + this.minSpace.width));
      this.numColumns = Math.max(1, Math.min(this.maxColumns, columns));
      this.numRows = Math.ceil(this.collectionView.getSectionLength(0) / this.numColumns); // Compute the available width (minus the space between items)

      var width = availableWidth - this.minSpace.width * Math.max(0, this.numColumns - 1); // Compute the item width based on the space available

      var itemWidth = Math.floor(width / this.numColumns);
      itemWidth = Math.max(this.minItemSize.width, Math.min(this.maxItemSize.width, itemWidth)); // Compute the item height, which is proportional to the item width

      var t = (itemWidth - this.minItemSize.width) / this.minItemSize.width;
      var itemHeight = this.minItemSize.height + this.minItemSize.height * t;
      itemHeight = Math.max(this.minItemSize.height, Math.min(this.maxItemSize.height, itemHeight)) + this.itemPadding;
      this.itemSize = new _collectionView.Size(itemWidth, itemHeight); // Compute the horizontal spacing and content height

      this.horizontalSpacing = Math.floor((this.collectionView.size.width - this.numColumns * this.itemSize.width) / (this.numColumns + 1));
      this.contentHeight = this.margin * 2 + this.numRows * this.itemSize.height + (this.numRows - 1) * this.minSpace.height;
    }
  }, {
    key: "getDropTarget",
    value: function getDropTarget(point) {
      var dropPosition = this.component.props.dropPosition === 'on' && !this.collectionView._dragTarget ? _collectionView.DragTarget.DROP_ON : _collectionView.DragTarget.DROP_BETWEEN; // If we are dropping between rows, the target should move to the
      // next item halfway through a row.

      if (dropPosition === _collectionView.DragTarget.DROP_BETWEEN) {
        point = point.copy();
        point.x += (this.itemSize.width + this.horizontalSpacing) / 2;
      }

      var indexPath;

      if (dropPosition === _collectionView.DragTarget.DROP_ON) {
        indexPath = this.collectionView.indexPathAtPoint(point);
      } else {
        var _index = this.getIndexAtPoint(point.x, point.y, true);

        indexPath = new _collectionView.IndexPath(0, _index);
      }

      if (indexPath) {
        return new _collectionView.DragTarget('item', indexPath, dropPosition);
      }

      var index = dropPosition === _collectionView.DragTarget.DROP_ON ? 0 : this.collectionView.getSectionLength(0);
      return new _collectionView.DragTarget('item', new _collectionView.IndexPath(0, index), _collectionView.DragTarget.DROP_BETWEEN);
    }
  }, {
    key: "getContentSize",
    value: function getContentSize() {
      return new _collectionView.Size(this.collectionView.size.width, this.contentHeight);
    }
  }, {
    key: "indexPathAbove",
    value: function indexPathAbove(indexPath) {
      return this.collectionView.incrementIndexPath(indexPath, -this.numColumns);
    }
  }, {
    key: "indexPathBelow",
    value: function indexPathBelow(indexPath) {
      return this.collectionView.incrementIndexPath(indexPath, this.numColumns);
    }
  }, {
    key: "indexPathLeftOf",
    value: function indexPathLeftOf(indexPath) {
      return this.collectionView.incrementIndexPath(indexPath, -1);
    }
  }, {
    key: "indexPathRightOf",
    value: function indexPathRightOf(indexPath) {
      return this.collectionView.incrementIndexPath(indexPath, 1);
    }
  }]);
  return GridLayout;
}(_BaseLayout2["default"]);

exports["default"] = GridLayout;