"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _classnames = _interopRequireDefault(require("classnames"));

var _convertUnsafeMethod = _interopRequireDefault(require("../../utils/convertUnsafeMethod"));

var _filterDOMProps = _interopRequireDefault(require("../../utils/filterDOMProps"));

var _FocusManager = _interopRequireDefault(require("../../utils/FocusManager"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireWildcard(require("react"));

var _class, _class2, _temp;

if (process.env.SCALE_MEDIUM && process.env.SCALE_LARGE) {
  require("../../spectrum-css/buttongroup/index.css");

  require("../../spectrum-css/buttongroup/index-diff.css");
} else if (process.env.SCALE_LARGE) {
  require("../../spectrum-css/buttongroup/index-lg.css");
} else {
  require("../../spectrum-css/buttongroup/index.css");
}

var BUTTONGROUP_ITEM_SELECTOR = '.spectrum-ButtonGroup-item:not([disabled]):not([aria-disabled])';
var BUTTONGROUP_SELECTED_ITEM_SELECTOR = BUTTONGROUP_ITEM_SELECTOR + '[aria-checked=true].is-selected';
var ALLOWED_BUTTON_VARIANTS = {
  tool: true,
  action: true
};

var ButtonGroup = (0, _convertUnsafeMethod["default"])(_class = (_temp = _class2 =
/*#__PURE__*/
function (_Component) {
  (0, _inherits2["default"])(ButtonGroup, _Component);

  function ButtonGroup(props) {
    var _this;

    (0, _classCallCheck2["default"])(this, ButtonGroup);
    _this = (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(ButtonGroup).call(this, props));
    _this.state = {
      value: props.value
    };
    return _this;
  }

  (0, _createClass2["default"])(ButtonGroup, [{
    key: "UNSAFE_componentWillReceiveProps",
    value: function UNSAFE_componentWillReceiveProps(props) {
      if (props.value && props.value !== this.state.value) {
        this.setState({
          value: props.value
        });
      }
    }
  }, {
    key: "addSelection",
    value: function addSelection(button) {
      return [].concat((0, _toConsumableArray2["default"])(this.state.value || []), [button.value]);
    }
  }, {
    key: "removeSelection",
    value: function removeSelection(button) {
      var value = this.state.value || [];
      var index = value.indexOf(button.value);
      return [].concat((0, _toConsumableArray2["default"])(value.slice(0, index)), (0, _toConsumableArray2["default"])(value.slice(index + 1, value.length)));
    }
  }, {
    key: "handleSelect",
    value: function handleSelect(button, e) {
      if (!this.props.readOnly && !button.readOnly) {
        var nextButtons;

        if (this.props.multiple) {
          if (this.isSelected(button)) {
            nextButtons = this.removeSelection(button);
          } else {
            nextButtons = this.addSelection(button);
          }
        } else {
          nextButtons = button.value;
        } // Set state if in uncontrolled mode


        if (!('value' in this.props)) {
          this.setState({
            value: nextButtons
          });
        }

        if (this.props.onChange) {
          this.props.onChange(nextButtons, e);
        }
      } // Support button's onClicks


      if (button.onClick) {
        button.onClick(e);
      } // Allow's the ButtonGroup's onClick to be called when a button is clicked


      if (this.props.onClick) {
        this.props.onClick(button.value, e);
      }
    }
    /**
     * @private
     * Evaluates whether button element is selected.
     * @param   {Object}  button Button properties object
     * @returns {Boolean} true if button is selected
     */

  }, {
    key: "isSelected",
    value: function isSelected(button) {
      if (this.props.readOnly) {
        return null;
      }

      return this.props.multiple ? this.state.value && this.state.value.indexOf(button.value) >= 0 : this.state.value === button.value;
    }
    /**
     * @private
     * The role to be used by buttons within the group. If the button group is readOnly,
     * button should retain their implicit role of button. With multiple selection, buttons
     * should have role of checkbox, and with single selection buttons should have role of radio.
     * @returns {String} role of buttons within group, either null, radio or checkbox.
     */

  }, {
    key: "getChildRole",
    value: function getChildRole() {
      if (this.props.readOnly) {
        return null;
      }

      return this.props.multiple ? 'checkbox' : 'radio';
    }
  }, {
    key: "getChildProps",
    value: function getChildProps(button, index) {
      var invalid = this.props.invalid || button.props.invalid;
      var required = this.props.required || button.props.required;
      var disabled = this.props.disabled || button.props.disabled;
      var selected = this.isSelected(button.props);
      var role = this.getChildRole();
      var onClick = !disabled ? this.handleSelect.bind(this, button.props) : null;
      var allowedVariant = ALLOWED_BUTTON_VARIANTS[button.props.variant];
      var classes = (0, _classnames["default"])('spectrum-ButtonGroup-item', button.props.className);
      return {
        className: classes,
        selected: selected,
        disabled: disabled,
        variant: allowedVariant ? button.props.variant : 'action',
        quiet: allowedVariant ? button.props.quiet : true,
        onClick: onClick,
        onKeyDown: button.props.onKeyDown,
        role: role,
        'aria-checked': selected,
        'aria-invalid': invalid,
        'aria-required': required
      };
    }
  }, {
    key: "renderButtons",
    value: function renderButtons() {
      var _this2 = this;

      var children = this.props.children;
      return _react["default"].Children.map(children, function (child, index) {
        return child ? _react["default"].cloneElement(child, _this2.getChildProps(child, index)) : null;
      });
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props = this.props,
          _this$props$children = _this$props.children,
          children = _this$props$children === void 0 ? [] : _this$props$children,
          className = _this$props.className,
          multiple = _this$props.multiple,
          disabled = _this$props.disabled,
          readOnly = _this$props.readOnly,
          invalid = _this$props.invalid,
          required = _this$props.required,
          orientation = _this$props.orientation,
          manageTabIndex = _this$props.manageTabIndex,
          role = _this$props.role,
          otherProps = (0, _objectWithoutProperties2["default"])(_this$props, ["children", "className", "multiple", "disabled", "readOnly", "invalid", "required", "orientation", "manageTabIndex", "role"]);
      delete otherProps.onChange;
      delete otherProps.onClick;

      if (!role) {
        if (!readOnly && !multiple) {
          // With single-selection, the wrapper element should have role=radiogroup.
          role = 'radiogroup';
        } else if (readOnly || children.length > 2) {
          // With readOnly and more than one button, the wrapper element should have role=toolbar, otherwise with less than two items or multi-selection, use role=group.
          role = readOnly && children.length > 2 ? 'toolbar' : 'group';
        }
      }

      return _react["default"].createElement(_FocusManager["default"], {
        itemSelector: BUTTONGROUP_ITEM_SELECTOR,
        selectedItemSelector: BUTTONGROUP_SELECTED_ITEM_SELECTOR,
        orientation: role === 'toolbar' ? orientation : 'both',
        manageTabIndex: manageTabIndex
      }, _react["default"].createElement("div", (0, _extends2["default"])({
        "aria-invalid": invalid || null,
        "aria-required": required || null,
        "aria-disabled": disabled || null,
        "aria-orientation": orientation !== 'both' && role === 'toolbar' ? orientation : null,
        role: role
      }, (0, _filterDOMProps["default"])(otherProps), {
        className: (0, _classnames["default"])('spectrum-ButtonGroup', {
          'spectrum-ButtonGroup--vertical': orientation === 'vertical'
        }, className)
      }), this.renderButtons(children)));
    }
  }]);
  return ButtonGroup;
}(_react.Component), (0, _defineProperty2["default"])(_class2, "propTypes", {
  /**
   * All buttons in ButtonGroup are disabled, greyed out and cannot be interacted with.
   */
  disabled: _propTypes["default"].bool,

  /**
   * Will override all child buttons invalid
   */
  invalid: _propTypes["default"].bool,

  /**
   * Whether to use roving tabIndex so that only one element within the group can receive focus with tab key at a time.
   */
  manageTabIndex: _propTypes["default"].bool,

  /**
   * Allows multi select
   */
  multiple: _propTypes["default"].bool,

  /**
   * Won't allow a permanent selection
   */
  readOnly: _propTypes["default"].bool,

  /**
   * Will override all child buttons required
   */
  required: _propTypes["default"].bool,

  /**
   * Called whenever a button is selected (non-readonly mode)
   */
  onChange: _propTypes["default"].func,

  /**
   * Called whenever a button is clicked (readonly mode)
   */
  onClick: _propTypes["default"].func,

  /**
   * Renders the button group as a row or a column
   */
  orientation: _propTypes["default"].oneOf(['horizontal', 'vertical', 'both']),

  /**
   * Value to select one or more buttons in the group. Accepts an array of strings if multiple=true,
   * otherwise accepts a string
   */
  value: _propTypes["default"].oneOfType([_propTypes["default"].string, _propTypes["default"].arrayOf(_propTypes["default"].string)])
}), (0, _defineProperty2["default"])(_class2, "defaultProps", {
  disabled: false,
  invalid: false,
  manageTabIndex: true,
  multiple: false,
  readOnly: false,
  required: false,
  orientation: 'both'
}), _temp)) || _class;

exports["default"] = ButtonGroup;