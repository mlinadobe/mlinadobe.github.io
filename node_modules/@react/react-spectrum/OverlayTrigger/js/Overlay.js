"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _autobindDecorator = _interopRequireDefault(require("autobind-decorator"));

var _closest = _interopRequireDefault(require("dom-helpers/query/closest"));

var _convertUnsafeMethod = _interopRequireDefault(require("../../utils/convertUnsafeMethod"));

var _OpenTransition = _interopRequireDefault(require("../../utils/OpenTransition"));

var _ownerDocument = _interopRequireDefault(require("react-overlays/lib/utils/ownerDocument"));

var _Portal = _interopRequireDefault(require("react-overlays/lib/Portal"));

var _Position = _interopRequireDefault(require("./Position"));

var _react = _interopRequireDefault(require("react"));

var _reactDom = _interopRequireDefault(require("react-dom"));

var _RootCloseWrapper = _interopRequireDefault(require("react-overlays/lib/RootCloseWrapper"));

var _class, _class2, _temp;

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var VISIBLE_OVERLAYS = new Map();
var DEFAULT_BUCKET_KEY = 'all';

var Overlay = (0, _convertUnsafeMethod["default"])(_class = (0, _autobindDecorator["default"])(_class = (_temp = _class2 =
/*#__PURE__*/
function (_React$Component) {
  (0, _inherits2["default"])(Overlay, _React$Component);

  function Overlay(props) {
    var _this;

    (0, _classCallCheck2["default"])(this, Overlay);
    _this = (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(Overlay).call(this, props));
    _this.state = {
      exited: !_this.props.show
    };
    return _this;
  }

  (0, _createClass2["default"])(Overlay, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.setState({
        targetNode: _reactDom["default"].findDOMNode(this.props.target)
      });
      this.mounted = true;
      this.addOverlay();
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.mounted = false;
      this.removeOverlay();
    }
  }, {
    key: "addOverlay",
    value: function addOverlay() {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;
      var overlayBucketKey = this.overlayBucketKey;
      var visibleOverlays = VISIBLE_OVERLAYS.get(overlayBucketKey);

      if (!visibleOverlays) {
        VISIBLE_OVERLAYS.set(overlayBucketKey, []);
        visibleOverlays = VISIBLE_OVERLAYS.get(overlayBucketKey);
      }

      if (props.show && this.mounted && !visibleOverlays.includes(this)) {
        visibleOverlays.push(this);
      }
    }
  }, {
    key: "removeOverlay",
    value: function removeOverlay() {
      // Remove overlay from the stack of visible overlays
      var visibleOverlays = VISIBLE_OVERLAYS.get(this.overlayBucketKey);
      var index = visibleOverlays.indexOf(this);

      if (index >= 0) {
        visibleOverlays.splice(index, 1);
      }
    }
  }, {
    key: "UNSAFE_componentWillReceiveProps",
    value: function UNSAFE_componentWillReceiveProps(nextProps) {
      if (nextProps.target && nextProps.target !== this.props.target) {
        this.setState(_objectSpread({}, this.state, {
          targetNode: _reactDom["default"].findDOMNode(nextProps.target)
        }));
      }
    }
  }, {
    key: "onEntered",
    value: function onEntered() {
      this.setState(_objectSpread({}, this.state, {
        exited: false
      }));
      this.addOverlay();

      if (this.props.onEntered) {
        var _this$props;

        (_this$props = this.props).onEntered.apply(_this$props, arguments);
      }
    }
  }, {
    key: "onExited",
    value: function onExited() {
      this.setState(_objectSpread({}, this.state, {
        exited: true
      }));
      this.removeOverlay();

      if (this.props.onExited) {
        var _this$props2;

        (_this$props2 = this.props).onExited.apply(_this$props2, arguments);
      }
    }
  }, {
    key: "getOverlayContainer",
    value: function getOverlayContainer(target) {
      var immediateAvailableContainer = (0, _closest["default"])(this.state.targetNode, '.react-spectrum-provider');
      return this.props.container || immediateAvailableContainer;
    }
  }, {
    key: "hide",
    value: function hide(e) {
      var visibleOverlays = VISIBLE_OVERLAYS.get(this.overlayBucketKey); // Only hide if this is the top overlay

      if (visibleOverlays[visibleOverlays.length - 1] === this && this.props.onHide) {
        this.props.onHide(e);
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var _this$props3 = this.props,
          containerPadding = _this$props3.containerPadding,
          target = _this$props3.target,
          _this$props3$containe = _this$props3.container,
          container = _this$props3$containe === void 0 ? this.getOverlayContainer(target) : _this$props3$containe,
          placement = _this$props3.placement,
          offset = _this$props3.offset,
          crossOffset = _this$props3.crossOffset,
          flip = _this$props3.flip,
          _this$props3$boundari = _this$props3.boundariesElement,
          boundariesElement = _this$props3$boundari === void 0 ? function () {
        return (0, _ownerDocument["default"])(_this2).body;
      } : _this$props3$boundari,
          shouldUpdatePosition = _this$props3.shouldUpdatePosition,
          rootClose = _this$props3.rootClose,
          children = _this$props3.children,
          show = _this$props3.show,
          onExit = _this$props3.onExit,
          onExiting = _this$props3.onExiting,
          onEnter = _this$props3.onEnter,
          onEntering = _this$props3.onEntering; // Don't un-render the overlay while it's transitioning out.

      var mountOverlay = show || !this.state.exited;

      if (!mountOverlay) {
        // Don't bother showing anything if we don't have to.
        return null;
      }

      var child = children; // Position is be inner-most because it adds inline styles into the child,
      // which the other wrappers don't forward correctly.

      child = _react["default"].createElement(_Position["default"], {
        container: container,
        containerPadding: containerPadding,
        target: target,
        placement: placement,
        shouldUpdatePosition: shouldUpdatePosition,
        offset: offset,
        crossOffset: crossOffset,
        flip: flip,
        boundariesElement: boundariesElement
      }, child); // This animates the child node by injecting props, so it must precede
      // anything that adds a wrapping div.

      child = _react["default"].createElement(_OpenTransition["default"], {
        "in": show,
        appear: true,
        onExit: onExit,
        onExiting: onExiting,
        onExited: this.onExited,
        onEnter: onEnter,
        onEntering: onEntering,
        onEntered: this.onEntered
      }, child); // This goes after everything else because it adds a wrapping div.

      if (rootClose) {
        child = _react["default"].createElement(_RootCloseWrapper["default"], {
          onRootClose: this.hide
        }, child);
      }

      return _react["default"].createElement(_Portal["default"], {
        container: container
      }, child);
    }
  }, {
    key: "overlayBucketKey",
    get: function get() {
      var children = this.props.children;

      if (children && children.props) {
        return children.props.role === 'tooltip' ? 'tooltip' : DEFAULT_BUCKET_KEY;
      }

      return DEFAULT_BUCKET_KEY;
    }
  }]);
  return Overlay;
}(_react["default"].Component), (0, _defineProperty2["default"])(_class2, "defaultProps", {
  placement: 'left'
}), _temp)) || _class) || _class;

exports["default"] = Overlay;